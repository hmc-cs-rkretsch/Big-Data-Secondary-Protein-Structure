'''
    Copyright (C) 2014 Pietro Sormanni

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    contacts: Pietro Sormanni
              e-mail: ps589@cam.ac.uk 
              Dept. of Chemistry
              University of Cambridge
              Cambridge, UK
              
    This program comes with ABSOLUTELY NO WARRANTY; 
    This is free software, and you are welcome to redistribute it
    under the condition of preserving this text
'''





# can be called as a script and runs s2D
import sys,os
from traceback import print_exc
from tempfile import gettempdir
#from Bio import SeqIO
#from Bio.Seq import Seq
#from Bio.SeqRecord import SeqRecord
#from Bio.Alphabet import generic_protein

'''
get blastdb

wget ftp://ftp.uniprot.org/pub/databases/uniprot/uniref/uniref90/uniref90.fasta.gz
gunzip -v uniref90.fasta.gz
bin/pfilt uniref90.fasta > uniref90filt
makeblastdb -t uniref90filt -i uniref90filt

'''

import s2D_class



plot=False # default option to generate or not the plot

module_path=str(s2D_class.__file__)
module_path=os.path.abspath( module_path[:module_path.rfind('/')])
if module_path[-1]!='/' : module_path+='/'
parameter_filename=module_path+'s2D_parameters.txt' # default name of the parameter file (a custom file can be provided in the command line)




class s2D_parameters:
    '''
    contains the values of the default parameters and the possibility to read a parameter files to read them
    '''
    def __init__(self,networkfiles=[],DL_network_file=''):
        self.networks=networkfiles # path to the networks (including N-to-1). Compulsory parameter
        self.DL_network=DL_network_file  # can set this to None to use averages of the networks above as a prediction (never tested, probably not working)
        # psiblast parameters
        self.use_psiblast_checkpoint=True # this reads psiblast results from a checkpoint file so that the scoring matrix is not rounded down to the next integer (2 decimals accuracy)
        self.psiblast_files_folder='psi_blast_files/'
        self.keep_pssm_profile_files=True
        self.psiblast_database='blastDB/uniref90filt.fasta'
        self.psiblast_ncpu=2 # number of cores allocated to run psiblast (see blast+ manual and look for option -num_threads therein)
        self.keep_psiblast_alignments=False # whether to keep the alignment generated by psiblast (these are not files with the PSSM)
        self.temporary_file_directory=gettempdir() # prints the current temporary directory
        if self.temporary_file_directory[-1]!='/' : self.temporary_file_directory+='/'
    def read(self,parameters_file=parameter_filename):
        if type(parameters_file) is str and not os.path.isfile(parameters_file) and '.net' in parameters_file and 'DL_network' in parameters_file : # if the relevant parameters have been hard coded in the source code
            pars=parameters_file.splitlines()
        else :
            pars=file(parameters_file).read().splitlines() # raise IOError if file is not found
        for line in pars :
            if line=='' or line[0]=='#' : continue
            if line[:len("DL_network")]=='DL_network' :
                self.DL_network = line.split()[1] 
            elif '.net' in line :
                for el  in line.split() :
                    if '.net' in el : self.networks+=[el]
            elif line[:4].lower()=='ncpu' :
                try :
                    self.psiblast_ncpu=int(line.split()[1])
                except Exception :
                    pass
            elif line[:len("psiblast_files_folder")]=='psiblast_files_folder' : self.psiblast_files_folder = line.split()[1]
            elif line[:len("psiblast_database")]=='psiblast_database' : self.psiblast_database  = line.split()[1]
            elif line[:len("use_psiblast_checkpoint")]=='use_psiblast_checkpoint'   :
                if line.split()[1].lower()=='false' : self.use_psiblast_checkpoint=False
                elif line.split()[1].lower()=='true' : self.use_psiblast_checkpoint=True
            elif line[:len("keep_psiblast_alignments")]=='keep_psiblast_alignments' :
                if line.split()[1].lower()=='true' : self.keep_psiblast_alignments=True
                elif line.split()[1].lower()=='false' : self.keep_psiblast_alignments=False
            elif line[:len("keep_pssm_profile_files")]=='keep_pssm_profile_files' :
                if line.split()[1].lower()=='true' : self.keep_pssm_profile_files=True
                elif line.split()[1].lower()=='false' : self.keep_pssm_profile_files=False
            elif 'temporary_file_directory' in line : self.temporary_file_directory=line.split()[1]
### OLD BACKCOMPATIBILITY TO DELETE
            elif 'psipred' in line and line.split()[1].lower()=='true': self.use_psiblast_checkpoint=True
            elif line[:len("psipred_blast_folder")]=='psipred_blast_folder' : self.psiblast_files_folder = line.split()[1]
        
        if len(self.networks)==0 :
            raise Exception ("**ERROR** No network files found in %s" % (parameters_file))
        
        if self.temporary_file_directory.lower()=='true' : self.temporary_file_directory=gettempdir() # prints the current temporary directory
        if self.temporary_file_directory[-1]!='/' : self.temporary_file_directory+='/'
        if self.psiblast_files_folder[-1]!='/' : self.psiblast_files_folder+='/'
        if not s2D_class.WEBSERVER_MODE :
            sys.stdout.write( "PARAMETERS read from %s\n" % (parameters_file))
            sys.stdout.flush()
    def write(self,outfilename):
        out=open(outfilename,'w')
        out.write('\n'.join(self.networks)+'\n')
        out.write('\t'.join(['DL_network',self.DL_network])+'\n')
        out.write('\t'.join(['psiblast_database',self.psiblast_database])+'\n')
        out.write('\t'.join(['psiblast_files_folder',self.psiblast_files_folder])+'\n')
        out.write('\t'.join(['use_psiblast_checkpoint',str(self.use_psiblast_checkpoint)])+'\n')
        out.write('\t'.join(['keep_psiblast_alignments',str(self.keep_psiblast_alignments)])+'\n')
        out.write('\t'.join(['keep_pssm_profile_files', str(self.keep_pssm_profile_files) ])+'\n')
        out.write('\t'.join(['temporary_file_directory',str(self.temporary_file_directory)])+'\n')
        out.write('\t'.join(['ncpu',str(self.psiblast_ncpu)])+'\n')
        out.close()


amino_list1=['A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y']


def get_file_path_and_extension(complete_filename) :
    '''
    given a complete path to a file (or just a file name) it returns path,name,extension
    '''
    if '/' in complete_filename :
        path=complete_filename[:complete_filename.rfind('/')+1]
        rest=complete_filename[complete_filename.rfind('/')+1:]
        if '.' in rest :
            name=rest[:rest.find('.')]
            extension=rest[rest.find('.'):]
        else :
            name=rest
            extension=''
    else :
        path=''
        if '.' in complete_filename :
            name=complete_filename[:complete_filename.find('.')]
            extension=complete_filename[complete_filename.find('.'):]
        else :
            name=complete_filename
            extension=''
    return path,name,extension

class FakeSeq :
    # mimic of the Biopython SeqRecord object, but in this way there is no need to have biopython installed
    def __init__(self,seq='',seq_id='',seq_name='',description='') :
        self.seq=seq
        self.id=seq_id
        self.name=seq_name
        self.description=description
    def __len__(self) :
        return len(self.seq)
    def __str__(self):
        return self.seq
    def __repr__(self):
        restr='FakeSeq:%s:' % (self.name)
        if len(self.seq)>20 :
            restr+=self.seq[:15]+'...'+self.seq[-2:]
        else : restr+=self.seq
        return restr
    def __getslice__(self,i,j):
        return self.seq[i:j]
    def __getitem__(self,y):
        return self.seq[y]
    def __add__(self,y):
        return FakeSeq(seq=self.seq+str(y),seq_id=self.id,seq_name=self.name,description=self.description)

def uniq(input_el):
#given list/tuple it returns the unique elements (in the order they first appear)
    output = []
    for x in input_el:
        if x not in output:
            output.append(x)
    return output

def read_fasta(filename, return_as_dictionary=False, description_parser_function=None,use_seq_class=True, check_sequence=amino_list1, name_first_spilt=True): 
    sequences=[]
    ids=[]
    names=[]
    descriptions=[]
    remove=[]
    first_residues=[]
    nseq=0
    for line in open(filename) :
        if line[0]=='>' :
            line=line[1:].strip()
            if description_parser_function!=None :
                seqid, name, description= description_parser_function(line)
            elif name_first_spilt:
                name=line.split()[0]
                seqid=name
                description=line[len(name)+1:] # could be ''
            else : 
                description=''
                name=line
                seqid=line
            if use_seq_class :
                sequences+=[ FakeSeq(seq='',seq_id=seqid,seq_name=name,description=description)]
            else :
                sequences+=['']
            if '|' in name : # for uniprot downloaded regions (e.g. without signal peptides) the last part may be the amino acid range
                putative_range=name.split('|')[-1]
                if '-' in putative_range :
                    try :
                        start,end=map(int, putative_range.split('-'))
                        first_residues+=[start]
                    except Exception : first_residues+=[1]
                else : first_residues+=[1]
            else : first_residues+=[1] 
            names+=[name]
            ids+=[seqid]
            descriptions+=[description]
            if check_sequence!=None and nseq>0 :
                for j,aa in enumerate(sequences[-2]) :
                    if aa not in check_sequence :
                        sys.stderr.write("\n**ERROR** residue %d %s in sequence %d %s NOT STANDARD --> can't process\n" % (j+1,aa,nseq,names[-2]) )
                        sys.stderr.flush()
                        remove+=[nseq-1]
                        break
            nseq+=1
        elif line!='' and line!='\n' :
            sequences[-1]+=line.strip()
    if check_sequence!=None and nseq>0 :
        for j,aa in enumerate(sequences[-1]) :
            if aa not in check_sequence :
                sys.stderr.write("\n**ERROR** residue %d %s in sequence %d %s NOT STANDARD --> can't process\n" % (j+1,aa,nseq,names[-2]) )
                sys.stderr.flush()
                remove+=[nseq-1]
                break
    if remove!=[] :
        remove=uniq(remove)
        for j in sorted(remove,reverse=True) :
            sys.stderr.write("**** SKIPPING sequence %d %s  --> contains NOT STANDARD residues that s2D can't process\n" % (j+1,names[j]) )
            sys.stderr.flush()
            del sequences[j],ids[j],names[j],descriptions[j]
    if len(sequences)==0 :
        sys.stderr.write("\n**** WARNING *** NO VALID sequence in  %s\n" % (filename))
        sys.stderr.flush()
    if use_seq_class :
        return sequences,first_residues
    else :
        return sequences,ids,names,descriptions,first_residues

'''
def get_SeqRecords(filename, ALPHABET=generic_protein, check_sequences=False, file_format='fasta', return_as_dictionary=False ) :
    
    ASSUME IT IS A PROTEIN 
    get the sequence records from a file. 
    It returns a list of the SeqRecord of the sequences. records can be accessed with .seq (sequence, i.e. Seq, 
       for actual string use str(records[].seq)), .id id in the file, .name (sometimes equal to id, depends on format), 
       .description (the description, when included) and .dbxref which (if present) is a list with the cross-referenced database. 
    return_as_dictionary  uses records.to_dict() to convert the record into a dictionary and return it(from Bio import SeqIO)
    For a list of available formats see http://biopython.org/wiki/SeqIO#File_Formats
    from Bio.Alphabet import generic_dna, generic_protein, generic_rna, (and some iupac can be used as well, use import Bio and dir(Bio.Alphabet) for list (use dir also on subcategories)
    
    handle = open(filename,"rU")
    records=list(SeqIO.parse(handle,file_format,alphabet=ALPHABET))
    handle.close()
    del handle
    if check_sequences :
        for record in records :
            if record.seq[-1]=='*' :
                record.seq=record.seq[:-1]
            for res in record.seq :
                if res not in amino_list1 :
                    print '** Warning res %s in %s is non standard. This can affect the quality of the prediciton' % (res,record.id)
    if return_as_dictionary : return SeqIO.to_dict(records)
    return records
'''

def parse_str_list_for_s2D( argv_1 ) :
    records=[]
    first_residues=[]
    i=1
    fid=None
    for f in argv_1 :
        if os.path.isfile(f) : # threat it as a fasta formatted file
            if fid==None : _,fid,_=get_file_path_and_extension(f)
            else : fid=None
            recs,first_res=read_fasta(f)
            records+= recs
            first_residues+=first_res
            print '%d sequences in file %s' % (len(records),f)
        else :
            s=''
            first_residues+=[1]
            for j,letter in enumerate(f.upper()) : # threat it as a sequence
                if letter in amino_list1 :
                    s+=letter
                else :
                    sys.stderr.write( 'NON STANDARD RESIDUE was removed from the input: symbol %s at position %d\n' % (letter,j+1))
                    sys.stderr.flush()
            records.append(  FakeSeq(s,'seq_'+str(i),'seq_'+str(i)) )
            i+=1
    return records,fid,first_residues





def run(argv_1, parameter_filename=parameter_filename,plot=plot,plotCoil=False,NCPU=None,outid=None,savefolder='',dpi=150):
    if type(argv_1) is not list : argv_1=[argv_1]
    
    if '-plot'  in argv_1 :
        plot=True # default value declared at beginning of file
        argv_1.remove('-plot')
        if not s2D_class.can_plot :
            sys.stderr.write("*** WARNING *** Cannot make plots. Problems when trying to import matplotlib, maybe you don't have version >= 1.4.\n")
            sys.stderr.flush()
            plot=False
    if '-plotCoil'  in argv_1 :
        plot=True # default value declared at beginning of file
        plotCoil=True
        argv_1.remove('-plotCoil')
        if not s2D_class.can_plot :
            sys.stderr.write("*** WARNING *** Cannot make plots. Problems when trying to import matplotlib, maybe you don't have version >= 1.4.\n")
            sys.stderr.flush()
            plot=False
    if '-NOplot'  in argv_1 :
        argv_1.remove('-NOplot')   
        plot=False
    elif '-noPlot'  in argv_1 :
        argv_1.remove('-noPlot')   
        plot=False
    found_custom_parameter_file,par_filename= s2D_class.loose_compare_keyword('.par',argv_1,end_with=True )
    if found_custom_parameter_file :
        parameter_filename=par_filename
        argv_1.remove(par_filename)
        sys.stdout.write("Using custom parameter files %s\n" % (parameter_filename))
    
    # read parameters
    parms=s2D_parameters()
    parms.read(parameter_filename)
    if savefolder!=None and savefolder!='' : 
        if savefolder[-1]!='/' :savefolder+='/'
        parms.temporary_file_directory=savefolder
        
    
    if not os.path.isdir(parms.temporary_file_directory) : os.system('mkdir %s' % (parms.temporary_file_directory) )
    if not os.path.isdir(parms.psiblast_files_folder) : os.system('mkdir %s' % (parms.psiblast_files_folder) )
    
    if len(parms.networks)==0 :
            raise Exception ("No network files found in %s" % (parameter_filename))
    
    if NCPU!=None : 
        if not s2D_class.WEBSERVER_MODE : sys.stdout.write('-num_threads = %d\n' % (NCPU))
        parms.psiblast_ncpu=NCPU
    # parse input sequence/file
    records,fid,first_residues=parse_str_list_for_s2D(argv_1)
    if outid!=None : 
        fid=outid
        if len(records)==1 : records[0].id, records[0].name=outid,outid
    
    # init predictor (load networks)
    predictor=s2D_class.s2D_method( network_files=parms.networks, deep_learning_net_file=parms.DL_network, temporary_file_directory=parms.temporary_file_directory \
                   , folder_with_psiblast_files=parms.psiblast_files_folder, uniref90_psi_blast_database=parms.psiblast_database \
                   , use_psiblast_checkpoint=parms.use_psiblast_checkpoint, psiblast_ncpu=parms.psiblast_ncpu,keep_pssm_profile_files=parms.keep_pssm_profile_files)
    
    # name output file
    if fid==None : outname='s2D_out.txt'
    else : outname=fid+'_s2D_out.txt'
    if savefolder!=None and savefolder!='' : outname=savefolder+outname
    if records==[] or records==None :
        sys.stderr.write("\n\n ***   NO VALID SEQUENCES GIVEN AS INPUT  --> Aborting ***\n\n")
        sys.stderr.flush()
        return 1
    
    # RUN and save output
    outfile=open(outname,'w')
    N=len(records)
    skip_error=0 # number of sequences skipped
    skip_short=0
    sys.stderr.flush()
    sys.stdout.flush()
    for j,seq in enumerate(records) :
        if j%20==0 and j>0: # if running on large number of sequence print progress every 20 sequences
            sys.stdout.write("\n--> %d of %d, %5.2lf%%\n" % (j,N,100.*j/N))
            sys.stdout.flush()
        if len(seq)< predictor.max_window_size: 
            sys.stderr.write("**ERROR** SKIPPING sequence %d %s The sequence is too short!!\n\n" % (j,seq.id))
            sys.stderr.flush()
            skip_short+=1
            continue
        #seq.id=seq.id.replace('|','').replace(' ','_').replace('/','').replace(':','_')
        
        try :
            predictor.run( seq, keep_psiblast_alignments= parms.keep_psiblast_alignments )
        except Exception :
            print_exc(file=sys.stderr)
            sys.stderr.write("**ERROR** SKIPPING sequence %d %s\n\n" % (j,seq.id))
            skip_error+=1
            continue
        if predictor.input==None or predictor.output==None :
            sys.stderr.write("**ERROR** SKIPPING sequence %d %s\n\n" % (j,seq.id))
            sys.stderr.flush()
            skip_error+=1
            continue
        predictor.print_results(outfile)
        if plot : # plot name: self.seq_name.replace('|', '_').replace(' ', '_').replace('/', '_').replace(':', '_') + '_s2D_plot.png' 
            predictor.plot_results(save=True,show=False,plotCoil=plotCoil,dpi=dpi,savefolder=savefolder, start_rescount=first_residues[j]) # plot figure if asked to
    
    outfile.close()
    
    if not s2D_class.WEBSERVER_MODE :
        sys.stdout.write("\n--> RUN FINISHED, results in %s\n" % (outname) )
    
    if skip_error>0 or skip_short>0 :
        sys.stdout.write("\n  %d sequences skipped because too short and %d because Exceptions were raised (among %d sequences given as input)\n"  % (skip_short,skip_error,N))
    sys.stdout.write("\n")
    sys.stdout.flush()
    return 0


if __name__=='__main__' :
    if len(sys.argv)<2 :
        sys.stderr.write("\n**ERROR**\nNO INPUT\nUSAGE: s2D runs with: 'INPUT [a_parameter_file_with_EXTENSION_.par] [-plot] [-plotCoil] [-NOplot] [-num_threads int_value]'\n where INPUT should be either a protein sequence in capital 1-letter notation (only the 20 standard amino acids) or a fasta file with one or more protein sequences.\n Note also that a file named %s should be in the same location as s2D.py for the program to run [or a custom file can be provided in the command line as a_parameter_file_with_extension_.par]\n  -plot   tries to generate a plot (default %s)\n  -NOplot   prevent from generating a plot (this option is given as well, since the default -plot behavior can be changed at the top of the script)\n  -plotCoil   plots also the coil secondary structure population (otherwise only helix and strand are plotted (and coil population is what is missing to reach a sum of 1)\n  -num_threads int_value can be given as the number of threads to give to psiblast (see psiblast documentation)\n\n" % (parameter_filename,str(plot)))
        sys.exit(1)
    NCPU=None
    try :
        j=sys.argv.index('-num_threads')
        if j>0 : 
            NCPU=int(sys.argv[j+1])
            sys.argv=sys.argv[:j]+sys.argv[j+2:] # remove args
    except Exception :pass
    outid=None
    try :
        j=sys.argv.index('-outid')
        if j>0 : 
            outid=sys.argv[j+1]
            sys.argv=sys.argv[:j]+sys.argv[j+2:] # remove args
    except Exception :pass
    out_folder=None
    try :
        j=sys.argv.index('-out_folder')
        if j>0 : 
            out_folder=sys.argv[j+1]
            sys.argv=sys.argv[:j]+sys.argv[j+2:] # remove args
    except Exception :pass
    sys.exit( run(sys.argv[1:], NCPU=NCPU,outid=outid,savefolder=out_folder) )
